---
title: "데이터 저장 - 프로퍼티 리스트 (1)"
elements:
  - content
  - css
  - formatting
  - html
  - markup
categories:
  - Swift
tags:
  - Swift
  - Data
  - Propertylist
  - UserDefault



---





# 1.1 프로퍼티 리스트(Property List)란?

<br>

프로퍼티 리스트는 애플의 주요 소프트웨어 프레임워크에 이용되는 **객체 직렬화를 위한 XML 형식의 파일**이다. 

애플에서는 **간단한 데이터 계층을 표현하기 위한 추상화**라고 정의하고 있기도 하다.

쉽게 말해 비교적 **간단한 데이터를 XML 포맷에 맞추어 키(Key) - 값(Value) 형식으로 저장**하는 것이라고 할 수 있다.

<br>

프로퍼티 리스트는 대부분 앱의 공통 데이터나 주요 설정, 환경 설정 정보를 저장하는 용도로 사용된다. iOS 기반의 프로젝트에서는 항상 Info.plist 파일을 찾아볼 수 있는데, 이는 앱의 빌드와 실행에 필요한 환경 설정값을 저장하는 대표적인 시스템 프로퍼티 리스트 파일입니다.

<br>

![info-plist](/images/info-plist.png)

------

*프로젝트에 포함된 Info.plist 파일*

<br>

프로퍼티 리스트는 데이터의 타입을 추상화하여 저장한다. 여기서 추상화는 정확하고 구체적인 형태를 가리키는 구체화의 반대말로서, **일체의 개별적인 특성을 배제하고 공통성을 띠는 것**을 말한다.



우리가 프로그래밍 코드에서 문자열을 다룰 때 사용하는 데이터 타입은 대부부 구체화된 타입이다.

스위프트에서 제공하는 String, 파운데이션 프레임워크에서 제공하는 NSString, 코어 파운데이션 프레임워크에서 제공하는 CFString 타입이 있는데 각 타입은 모두 자신만의 독특한 특성이나 속성을 지니고 있다.



예를 들어, **String 타입**은 개별 문자열을 Character 타입으로 변환할 때는 **.character 속성**이 있고 문자열의 길이를 구할 때에는 **.character.count 속성**이 있지만 **NSString 타입**은 Character 타입으로 변환할 수 있는 **속성이 없고** 문자열의 길이를 구할 때에는 **.length 속성**을 사용한다. 이처럼 구체적인 타입들 각각의 특성이 모두 다르다.



하지만 이와 같은 각 타입의 문자열 데이터가 프로퍼티 리스트에 저장될 떄에는 모두 "문자열" 이라는 공통의 타입으로 추상화 된다. 정확히는 &#60;string&#62;타입이지만 스위프트의 String 과는 이름만 같을 뿐, 의미적으로는 다른 타입이다.



즉, 각각의 타입이 갖는 개별적이고 구체적인 특성은 모두 배제한 채 "문자열"이라는 공통된 특성만 추출(**추상화**)하여 <string> 타입으로 바꾸었기 때문에 String 타입으로 저장을 했어도 .character 속성을 사용할 수 없고 NSString 타입으로 저장을 했어도 .length  속성을 사용할 수 없다.



하지만 덕분에 프로퍼티 리스트에 저장된 데이터는 연관된 어느 타입으로든 읽어 올 수 있다.

String 타입의 값을 저장했더라도 이를 NSString 타입의 형태로 읽어올 수 있고, CFString 으로 읽어올 수도 있다.

<br>

![plist-data-abstract](/images/plist-data-abstract.png)

<br>

주의할 것은 프로퍼티 리스트가 데이터의 타입을 추상화하는 것이지, 결코 데이터 자체를 추상화하는 것은 아니라는 점입니다. 데이터 자체는 추상화할 수 없을 뿐더러, 추상화해서도 안 됩니다.

추상화하는 순간 값의 유실이 발생하기 때문입니다. 데이터는 그대로 보존하되 타입만 추상화하는 것이 프로퍼티 리스트에서 데이터를 저장하는 메커니즘의 핵심이라고 할 수 있습니다.

<br>

<br>

# 1.2 프로퍼티 리스트와 데이터 타입

<br>

프로퍼티 리스트에 저장할 수 있는 데이터 타입은 크게 두 가지로 구분할 수 있다.

하나는 **원시 타입(Primitive Data Type)**으로, 스위프트에서 제공하는 String, Int, Float, Double, Bool 등이 이에 해당한다. 이 타입으로 선언된 데이터들은 모두 프로퍼티 리스트에 저장할 수 있다.

또 다른 하나는 **레퍼런스 타입(Reference Data Type)**으로, 파운데이션 프레임워크에서 제공하는 NSString, NSNumber, NSDate, NSData 등이 여기에 속하며 코어 파운데이션 프레임워크에서 제공하는 CFString, CFNumber, CFDate, CFData 등도 역시 이 분류에 속한다.

프로퍼티 리스트에는 컨테이너 형태의 집합 자료형도 저장할 수 있다. 스위프트에서 제공하는 **Array, Dictionary** 파운데이션 프레임워크에서 제공하는 **NSArray, NSDictionary** 코어파운데이션에서 제공하는 **CFArray, CFDictionary** 등이 대표적인 집합 자료형들이다.

앞서 프로퍼티 리스트는 XML 형식을 따르는 파일 포맷이라고 설명한 바 있다. 따라서 프로퍼티 리스트에 데이터를 정의할 때에는 데이터를 둘러싼 <> 엘리먼트에 각각의 추상화된 데이터 타입을 표시하는 XML 문법을 그대로 적용해 주어야 한다.

프로퍼티 리스트에 사용할 수 있는 XML 엘리먼트와, 그에 대응하는 데이터 타입의 종류는 다음 표를 참고하자

<br>

|   타입   |       XML 엘리먼트       |   스위프트    |  파운데이션  | 코어파운데이션 |
| :------: | :----------------------: | :-----------: | :----------: | :------------: |
|   배열   |     &#60;array&#62;      |     Array     |   NSArray    |    CFArray     |
| 딕셔너리 |        &#60;dict>        |  Dictionary   | NSDictionary |  CFDictionary  |
|  문자열  |       &#60;string>       |    String     |   NSString   |    CFString    |
|   날짜   |        &#60;date>        |       -       |    NSDate    |     CFDate     |
| *Base64  |        &#60;data>        |       -       |    NSData    |     CFData     |
|   정수   |      &#60;integer>       |   Int, UInt   |   NSNumber   |    CFNumber    |
|   실수   |        &#60;real>        | Float, Double |   NSNumber   |    CFNumber    |
|  논리형  | &#60;true/>,&#60;false/> |     Bool      |   NSNumber   |    CFNumber    |

*프로퍼티 리스트의 XML 엘리먼트와 데이터 타입*

<br>

> *Base 64 란? 
>
> 8비트로 된 바이너리 데이터를 문자 코드에 영향을 받지 않는 공통의 아스키 코드를 사영하여 일련의 문자열로 바꾸는 방식을 의미합니다. 가령 실행 파일이나 ZIP 파일 등은 텍스트 기반이 아니라 바이너리 데이터로 이루어지는데, 이를 Base64로 인코딩하면 어느 문자 코드를 사용하든지 동일하게 읽어들일 수 있습니다. 
>
> Base64로 인코딩된 문자열은 의미 없는 문자열들이 나열된 형태를 이루며, 디코딩 과정을 거쳐 원래의 데이터로 복구됩니다.

<br>

위 표에 나열된 데이터 타입처럼 프로퍼티 리스트에 저장할 수 있는 데이터 타입들을 공통적으로 프로퍼티 객체 타입이라고 한다. 원칙적으로 프로퍼티 객체 타입이 아니면 프로퍼티 리스트에 저장할 수 없다. 데이터의 유실 없이 프로퍼티 리스트에 저장할 수 있는 형태로 데이터를 변환하는 메커니즘이 없기 때문이다. 이 때문에 배열이나 딕셔너리 등 집합 자료형 하위에 저장되는 데이터도 모두 프로퍼티 객체 타입이어야 한다.



물론, 프로퍼티 객체 타입에 혹하지 않아도 프로퍼티 리스트에 데이터를 저장할 수 있는 방법은 있다. 변환 매커니즘을 직접 구현해 줄 경우 데이터를 저장할 수 있고 이 매커니즘은 NSCoder 프로토콜을 통해 제공이 되기 때문에, 저장하고자 하는 데이터 객체가 이 프로토콜을 구현하도록 하면 된다.

<br>

|  항목명  |   저장할 값    |
| :------: | :------------: |
|   이름   |     민경준     |
|   성별   |       남       |
|   나이   |       26       |
| 결혼유무 |      안함      |
|   소원   |  100억원 당첨  |
|   국적   | [ 한국, 미국 ] |

<br>

위 데이터는 사용자 정보를 우리가 이해하기 쉬운 형태로 정리한 것이다. 사용자 정보를 이루는 각각의 항목은 그에 연결된 값을 가지는데 대부분은 문자열이지만, 일부는 다른 타입을 사용한다. 나이의 경우는 숫자, 국적은 배열 형태의 데이터를 사용한다.

다음은 사용자 정보를 프로퍼티 리스트 포맷으로 작성한 결과이다.

<br>

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
												"http://www.apple.com/DTDs/PropetyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>이름</key>
  <string>민경준</string>
  <key>성별</key>
  <string>남</string>
  <key>나이</key>
  <integer>26</integer>
  <key>결혼유무</key>
  <false/>
  <key>소원</key>
  <string>100억원 당첨</string>
  <key>국적</key>
  <array>
  	<string>한국</string>
    <string>미국</string>
  </array>  
</dict>
</plist>
```

<br>

상단에는 프로퍼티 리스트에 대한 형식 및 메타 정보들이 약 2,3줄 정도로 기재된다. 

해당 파일이 XML 문법 버전 1.0을 사용하고, utf-8로 인코딩되어 있으며, 엘리먼트들의 형식은 http://www.apple.com/DTDs/PropetyList-1.0.dtd 에 정의되어 있다는 내용이다.

DTD 라는 키워드는 SGML이라는 문법을 사용하여 문서 텍스트의 구조를 정의 및 기술한 것으로서 Documetn Type Definition이라는 단어의 약자이다. 한마디로 우리가 프로퍼티 리스트에서 사용할 문법 구조가 정의되어 있는 문서라고 할 수 있다.

<br>

<br>

# 1.3 프로퍼티 리스트 작성 실습

<br>

##### STEP 01. 

프로젝트 내비게이터에서 Chapter05-plist 폴더에 [마우스 우클릭] - [New File] 클릭 하여 Property List 파일을 추가한다. 파일 이름은 User.plist 로 했다.

![plist-test-1-1](/images/plist-test-1-1.png)

![plist-test-1-2](/images/plist-test-1-2.png)

------

*프로퍼티 리스트 추가*

<br>

##### STEP 02. 

추가된 User.plist 파일을 클릭하여 선택한다. 다음과 같이 프로퍼티 툴로 User.plist 가 열리는 것을 확인한다.

![plist-test-2](/images/plist-test-2.png)

------

*프로퍼티 툴에서 실행된 User.plist*

<br>

##### STEP 03.

현재 User.plist 파일에는 아무런 내용도 없기 때문에 프로퍼티 툴 역시 Root 노드를 제외하면 텅 비어 있는 상태이다. 유일한 항목인 Root는 편집 툴에서 하위 항목을 추가하기 위해 제공되는 가상의 최상위 노드로 단지 개념상으로만 존재하기 때문에 실제 XML 코드에는 포함되지 않는다.

![plist-test-3](/images/plist-test-3.png)

------

*User.plist 파일을 소스 코드 방식으로 열어본 모습*

<br>

##### STEP 04. 

Root 노드 위에 마우스 포인터를 올리면 그림과 같이 (+) 아이콘이 나타난다. 이 아이콘은 하위 노드를 추가하는 버튼이다. Root는 프로퍼티 툴에서 최상위 노드를 의미하므로 오직 하위 노드만 추가 할 수 있다.

![plist-test-4](/images/plist-test-4.png)

------

*Root 노드 위에 마우스를 올렸을 때 나타나는 (+) 아이콘*

<br>

##### STEP 05. 

추가된 노드는 다음 그림과 같이 표시된다. 좌측부터 차례대로 항목명 - 타입 - 내용을 나타낸다. 각 항목을 클릭하면 편집할 수 있는 상태로 바뀐다.

![plist-test-5](/images/plist-test-5.png)

------

*프로퍼티 툴의 편집 모드*

<br>

##### STEP 06. 

나이에 대한 Type 항목을 클릭하여 Number 타입으로 변경합니다. 실제로 작성된 XML을 열어보면 <integer&#62; 엘리먼트가 추가 되어 있다.

![plist-test-6](/images/plist-test-6.png)

------

*나이 항목에 대한 데이터 타입 변경*

<br>

##### STEP 07. 

위와 같은 방식들로 나머지 정보까지 모두 직접 입력한다. 모든 값이 입력되고 난 후의 User.plist는 다음과 같다.

![plist-test-7](/images/plist-test-7.png)

------

*User.plist에 개인 정보가 모두 등록 된 모습*

<br>

작성이 완료된 User.plist를 소스 코드 형식으로 열어 보면 다음과 같다. 위에서 사용자 정보를 프로퍼티 리스트 포맷으로 작성한것과 동일한 모습이다.

![plist-test-8](/images/plist-test-8.png)

------

*정보가 모두 등록된 User.plist 소스코드 형식의 모습*

<br>

이렇게 정의된 프로퍼티 리스트는 앱스토어에 앱을 등록할 때 사용되는 배포 파일인 ipa 파일에도 반입되었다가, 사용자의 기기에 앱이 설치될 때 함께 추가된다. 이때 프로퍼티 리스트가 설치되는 영역을 **앱 번들(App Bundle)**이라고 부르는데, 이는 주요 소스 코드와 설정 파일들이 저장 되는 매우 중요한 영역이다.

<br>

